/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package nbgeneticalgorithm;

/**
 *
 * @author Win7Sion
 */
import java.awt.Color;
import java.util.Random;
import javax.swing.JPanel;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.Arc2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.text.DecimalFormat;
import javax.swing.Timer;
import javax.imageio.ImageIO;

/**
 *
 * @author Win7Sion
 */
public class NBGeneticAlgorithm extends javax.swing.JFrame {

    //globals
    Random rNumber = new Random();
    boolean draw = false;
    boolean pause = false;

    int foodAmount, preyAmount, predAmount, mutation, minMutStrength, maxMutStrength;

    boolean showFov = false;

    Timer t_preyTimer;
    Timer t_predTimer;
    Timer t_foodTimer;

    Food[] foodPop;
    Prey[] preyPop;
    Predator[] predPop;

    BufferedImage grassImage;
    BufferedImage preyImage;
    BufferedImage predatorImage;

    GA ga = new GA();
    boolean newGen = false;

    ActionListener al_preyLogic, al_predLogic, al_foodLogic;

    int preySelected, predSelected;

    float decay = 0.2f;
    float predLife = 25.0f;
    float preyLife = 15.0f;

    int simSpeed = 0;
    int timerDelay;
    
    long startTime, duration, endTime;
    
    /**
     * Creates new form NBGeneticAlgorithmGUI
     */
    public NBGeneticAlgorithm() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialise the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        viewPort = new MyPanel(0,0,600,600);
        jlPreyPopulation = new javax.swing.JLabel();
        jtfPreyPopulation = new javax.swing.JTextField();
        jlPredatorPopulation = new javax.swing.JLabel();
        jtfPredatorPopulation = new javax.swing.JTextField();
        jlFoodPopulation = new javax.swing.JLabel();
        jtfFoodPopulation = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        jtaConsole = new javax.swing.JTextArea();
        jbStart = new javax.swing.JButton();
        jbReset = new javax.swing.JButton();
        jlFoodPopulationHint = new javax.swing.JLabel();
        jlPreyPopulationHint = new javax.swing.JLabel();
        jlPredatorPopulationHint = new javax.swing.JLabel();
        jtfPrey_Speed = new javax.swing.JTextField();
        jlPrey_Speed = new javax.swing.JLabel();
        jlPreyID = new javax.swing.JLabel();
        jtfPrey_ID = new javax.swing.JTextField();
        jlPrey_Energy = new javax.swing.JLabel();
        jlPrey_Fov_Width = new javax.swing.JLabel();
        jlPrey_Fov = new javax.swing.JLabel();
        jtfPrey_Fov_Width = new javax.swing.JTextField();
        jtfPrey_Energy = new javax.swing.JTextField();
        jtfPrey_Fov = new javax.swing.JTextField();
        jlPreyTurn_speed = new javax.swing.JLabel();
        jtfPrey_Turn_speed = new javax.swing.JTextField();
        jlMutation = new javax.swing.JLabel();
        jtfMutation = new javax.swing.JTextField();
        jlMutationHint = new javax.swing.JLabel();
        jtfPreyGeneration = new javax.swing.JTextField();
        jlPreyGeneration = new javax.swing.JLabel();
        jtfPred_ID = new javax.swing.JTextField();
        jlPred_Energy = new javax.swing.JLabel();
        jlPred_Fov_Width = new javax.swing.JLabel();
        jlPred_Fov = new javax.swing.JLabel();
        jtfPred_Energy = new javax.swing.JTextField();
        jtfPredGeneration = new javax.swing.JTextField();
        jtfPred_Fov_Width = new javax.swing.JTextField();
        jlPredGeneration = new javax.swing.JLabel();
        jtfPred_Fov = new javax.swing.JTextField();
        jlPredTurn_speed = new javax.swing.JLabel();
        jtfPred_Speed = new javax.swing.JTextField();
        jtfPred_Turn_speed = new javax.swing.JTextField();
        jlPred_Speed = new javax.swing.JLabel();
        jlPredID = new javax.swing.JLabel();
        jcbSimFast = new javax.swing.JCheckBox();
        jcbSimNormal = new javax.swing.JCheckBox();
        jcbSimSlow = new javax.swing.JCheckBox();
        jlSimSpeed = new javax.swing.JLabel();
        jcbFov = new javax.swing.JCheckBox();
        jlMaxStrHint = new javax.swing.JLabel();
        jlMutationStrHint = new javax.swing.JLabel();
        jtfMaxMutStr = new javax.swing.JTextField();
        jlMinMutStr = new javax.swing.JLabel();
        jtfMinMutStr = new javax.swing.JTextField();
        jlMinMutStrHint = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Prey Vs Predator Genetic Algorithm");
        setResizable(false);

        viewPort.setBackground(new java.awt.Color(0, 0, 0));
        viewPort.setFocusable(false);
        viewPort.setName("viewPort"); // NOI18N
        viewPort.setPreferredSize(new java.awt.Dimension(600, 600));
        viewPort.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                viewPortMouseMoved(evt);
            }
        });
        viewPort.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                viewPortMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout viewPortLayout = new javax.swing.GroupLayout(viewPort);
        viewPort.setLayout(viewPortLayout);
        viewPortLayout.setHorizontalGroup(
            viewPortLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 600, Short.MAX_VALUE)
        );
        viewPortLayout.setVerticalGroup(
            viewPortLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 600, Short.MAX_VALUE)
        );

        jlPreyPopulation.setText("Prey Population");

        jtfPreyPopulation.setText("0");
        jtfPreyPopulation.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jtfMaxMutStrKeyReleased(evt);
            }
        });

        jlPredatorPopulation.setText("Predator Population");

        jtfPredatorPopulation.setText("0");
        jtfPredatorPopulation.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jtfMaxMutStrKeyReleased(evt);
            }
        });

        jlFoodPopulation.setText("Food Population");

        jtfFoodPopulation.setText("0");
        jtfFoodPopulation.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jtfMaxMutStrKeyReleased(evt);
            }
        });

        jtaConsole.setColumns(20);
        jtaConsole.setRows(5);
        jtaConsole.setText("This is the console\n");
        jtaConsole.setToolTipText("");
        jScrollPane1.setViewportView(jtaConsole);

        jbStart.setText("Start");
        jbStart.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbStartActionPerformed(evt);
            }
        });

        jbReset.setText("Reset");
        jbReset.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbResetActionPerformed(evt);
            }
        });

        jlFoodPopulationHint.setText("2 - 1000");

        jlPreyPopulationHint.setText("2 - 1000");

        jlPredatorPopulationHint.setText("2 - 1000");

        jtfPrey_Speed.setEditable(false);

        jlPrey_Speed.setText("Speed");

        jlPreyID.setText("Prey ID");

        jtfPrey_ID.setEditable(false);

        jlPrey_Energy.setText("Energy");

        jlPrey_Fov_Width.setText("Fov Width");

        jlPrey_Fov.setText("Fov");

        jtfPrey_Fov_Width.setEditable(false);

        jtfPrey_Energy.setEditable(false);

        jtfPrey_Fov.setEditable(false);

        jlPreyTurn_speed.setText("Turn Speed");

        jtfPrey_Turn_speed.setEditable(false);

        jlMutation.setText("Mutation Chance");

        jtfMutation.setText("0");
        jtfMutation.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jtfMaxMutStrKeyReleased(evt);
            }
        });

        jlMutationHint.setText("0 - 100");

        jtfPreyGeneration.setEditable(false);

        jlPreyGeneration.setText("Prey Gen");

        jtfPred_ID.setEditable(false);

        jlPred_Energy.setText("Energy");

        jlPred_Fov_Width.setText("Fov Width");

        jlPred_Fov.setText("Fov");

        jtfPred_Energy.setEditable(false);

        jtfPredGeneration.setEditable(false);

        jtfPred_Fov_Width.setEditable(false);

        jlPredGeneration.setText("Pred Gen");

        jtfPred_Fov.setEditable(false);

        jlPredTurn_speed.setText("Turn Speed");

        jtfPred_Speed.setEditable(false);

        jtfPred_Turn_speed.setEditable(false);

        jlPred_Speed.setText("Speed");

        jlPredID.setText("Pred ID");

        jcbSimFast.setText("Fast");
        jcbSimFast.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jcbSimFastActionPerformed(evt);
            }
        });
        jcbSimFast.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jtfMaxMutStrKeyReleased(evt);
            }
        });

        jcbSimNormal.setText("Normal");
        jcbSimNormal.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jcbSimNormalActionPerformed(evt);
            }
        });
        jcbSimNormal.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jtfMaxMutStrKeyReleased(evt);
            }
        });

        jcbSimSlow.setText("Slow");
        jcbSimSlow.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jcbSimSlowActionPerformed(evt);
            }
        });
        jcbSimSlow.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jtfMaxMutStrKeyReleased(evt);
            }
        });

        jlSimSpeed.setText("Simulation Speed");

        jcbFov.setText("Fov");
        jcbFov.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jcbFovActionPerformed(evt);
            }
        });
        jcbFov.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jtfMaxMutStrKeyReleased(evt);
            }
        });

        jlMaxStrHint.setText("Max Mut Str");

        jlMutationStrHint.setText("0 - 100");

        jtfMaxMutStr.setText("0");
        jtfMaxMutStr.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jtfMaxMutStrKeyReleased(evt);
            }
        });

        jlMinMutStr.setText("Min Mut Str");

        jtfMinMutStr.setText("0");
        jtfMinMutStr.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jtfMaxMutStrKeyReleased(evt);
            }
        });

        jlMinMutStrHint.setText("0 - 100");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(viewPort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jbStart)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jbReset)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jcbFov)
                        .addGap(8, 8, 8))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jlMinMutStr)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jtfMinMutStr, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jlMinMutStrHint)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jlMaxStrHint)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jtfMaxMutStr, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jlMutationStrHint))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jlSimSpeed)
                                        .addGap(18, 18, 18)
                                        .addComponent(jcbSimSlow)
                                        .addGap(36, 36, 36)
                                        .addComponent(jcbSimNormal))
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(jlPrey_Fov_Width, javax.swing.GroupLayout.Alignment.TRAILING)
                                            .addComponent(jlPrey_Fov, javax.swing.GroupLayout.Alignment.TRAILING)
                                            .addComponent(jlPrey_Energy, javax.swing.GroupLayout.Alignment.TRAILING)
                                            .addComponent(jlPrey_Speed, javax.swing.GroupLayout.Alignment.TRAILING)
                                            .addComponent(jlPreyTurn_speed, javax.swing.GroupLayout.Alignment.TRAILING)
                                            .addComponent(jlPreyID, javax.swing.GroupLayout.Alignment.TRAILING)
                                            .addComponent(jlPreyGeneration, javax.swing.GroupLayout.Alignment.TRAILING))
                                        .addGap(18, 18, 18)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(jtfPrey_ID, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                                .addComponent(jtfPrey_Fov_Width, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addComponent(jtfPrey_Energy, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addComponent(jtfPrey_Fov, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE))
                                            .addComponent(jtfPrey_Turn_speed, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jtfPreyGeneration, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jtfPrey_Speed, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addGroup(layout.createSequentialGroup()
                                                .addGap(11, 11, 11)
                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                                    .addComponent(jlPred_Fov)
                                                    .addComponent(jlPredID)
                                                    .addComponent(jlPredGeneration)))
                                            .addComponent(jlPredTurn_speed)
                                            .addComponent(jlPred_Speed, javax.swing.GroupLayout.Alignment.TRAILING)
                                            .addComponent(jlPred_Energy, javax.swing.GroupLayout.Alignment.TRAILING)
                                            .addComponent(jlPred_Fov_Width, javax.swing.GroupLayout.Alignment.TRAILING))))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jtfPred_ID, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                            .addComponent(jtfPred_Fov_Width, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jtfPred_Energy, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jtfPred_Fov, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addComponent(jtfPred_Turn_speed, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(jtfPredGeneration, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(jtfPred_Speed, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addComponent(jcbSimFast, javax.swing.GroupLayout.Alignment.TRAILING)))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jlMutation)
                                    .addComponent(jlFoodPopulation)
                                    .addComponent(jlPreyPopulation, javax.swing.GroupLayout.PREFERRED_SIZE, 89, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jlPredatorPopulation))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addComponent(jtfFoodPopulation, javax.swing.GroupLayout.DEFAULT_SIZE, 50, Short.MAX_VALUE)
                                    .addComponent(jtfPreyPopulation, javax.swing.GroupLayout.DEFAULT_SIZE, 50, Short.MAX_VALUE)
                                    .addComponent(jtfMutation, javax.swing.GroupLayout.DEFAULT_SIZE, 50, Short.MAX_VALUE)
                                    .addComponent(jtfPredatorPopulation, javax.swing.GroupLayout.DEFAULT_SIZE, 50, Short.MAX_VALUE))
                                .addGap(29, 29, 29)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jlFoodPopulationHint)
                                    .addComponent(jlPreyPopulationHint)
                                    .addComponent(jlPredatorPopulationHint)
                                    .addComponent(jlMutationHint))))
                        .addGap(0, 20, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jlPreyPopulation)
                            .addComponent(jlPreyPopulationHint)
                            .addComponent(jtfPreyPopulation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jlPredatorPopulationHint)
                                .addComponent(jtfPredatorPopulation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jlPredatorPopulation, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jlFoodPopulation)
                            .addComponent(jtfFoodPopulation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jlFoodPopulationHint))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jlMutation)
                            .addComponent(jtfMutation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jlMutationHint))
                        .addGap(14, 14, 14)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jlMutationStrHint)
                            .addComponent(jtfMaxMutStr, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jlMaxStrHint)
                            .addComponent(jlMinMutStrHint)
                            .addComponent(jtfMinMutStr, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jlMinMutStr))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jcbSimFast)
                            .addComponent(jcbSimNormal)
                            .addComponent(jcbSimSlow)
                            .addComponent(jlSimSpeed))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addComponent(jlPreyGeneration)
                                    .addComponent(jtfPreyGeneration, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jtfPrey_ID, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jlPreyID))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jtfPrey_Turn_speed, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jlPreyTurn_speed))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jtfPrey_Speed, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jlPrey_Speed))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jtfPrey_Energy, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jlPrey_Energy))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jtfPrey_Fov_Width, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jlPrey_Fov_Width))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jtfPrey_Fov, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jlPrey_Fov)))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addComponent(jlPredGeneration)
                                    .addComponent(jtfPredGeneration, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                            .addComponent(jtfPred_ID, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jlPredID))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                            .addComponent(jtfPred_Turn_speed, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jlPredTurn_speed))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                            .addComponent(jtfPred_Speed, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jlPred_Speed))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                            .addComponent(jtfPred_Energy, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jlPred_Energy))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                            .addComponent(jtfPred_Fov_Width, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jlPred_Fov_Width))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jtfPred_Fov, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addComponent(jlPred_Fov, javax.swing.GroupLayout.Alignment.TRAILING))))
                        .addGap(9, 9, 9)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jbStart)
                            .addComponent(jbReset)
                            .addComponent(jcbFov)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(viewPort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 3, Short.MAX_VALUE)))
                .addContainerGap())
        );

        viewPort.getAccessibleContext().setAccessibleName("");
        viewPort.getAccessibleContext().setAccessibleDescription("");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /*
     Reset Button
     What it does : When this button is pressed it will delete all current information
     and restore all input values to default (usually 0) and re-enable any buttons
     */
    private void jbResetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbResetActionPerformed
        // TODO add your handling code here:
        foodAmount = 0;
        preyAmount = 0;
        predAmount = 0;
        preySelected = 0;
        predSelected = 0;
        minMutStrength = 0;
        maxMutStrength = 0;        
        resetFields();
        jcbSimFast.setEnabled(true);
        jcbSimSlow.setSelected(false);
        jcbSimNormal.setSelected(false);
        jcbSimFast.setSelected(false);
        jcbSimSlow.setEnabled(true);
        jcbSimNormal.setEnabled(true);
        jbStart.setEnabled(true);
        t_preyTimer.stop();
        t_predTimer.stop();
        t_foodTimer.stop();
        draw = false;
        ga.clear();
    }//GEN-LAST:event_jbResetActionPerformed

    public void resetFields() {
        jtfFoodPopulation.setText("0");
        jtfPreyPopulation.setText("0");
        jtfPredatorPopulation.setText("0");
        jtfPredGeneration.setText("0");
        jtfPred_Energy.setText("0");
        jtfPred_Fov.setText("0");
        jtfPred_Fov_Width.setText("0");
        jtfPred_ID.setText("0");
        jtfPred_Speed.setText("0");
        jtfPred_Turn_speed.setText("0");
        jtfPreyGeneration.setText("0");
        jtfPrey_Energy.setText("0");
        jtfPrey_Fov.setText("0");
        jtfPrey_Fov_Width.setText("0");
        jtfPrey_ID.setText("0");
        jtfPrey_Speed.setText("0");
        jtfPrey_Turn_speed.setText("0");
        jtfMinMutStr.setText("0");
        jtfMaxMutStr.setText("0");
    }

    /*
     Start Button 
     What it does : The start button takes all the input of the user, 
     validates it and then uses it to create the initial populations and
     finally begin running the simulation until the stop button is pressed
     Validation : Will only run the simulation if all values entered are
     correct. Otherwise will prompt user with message to the console
     with what is wrong.
     */
    private void jbStartActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbStartActionPerformed
        // TODO add your handling code here:
        String temp;

        boolean pass = false;

        al_foodLogic = new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                int foodEaten = 0;
                for (int i = 0; i < foodAmount; i++) {
                    if (!foodPop[i].isAlive()) {
                        foodEaten++;
                    }
                }

                if (foodEaten >= foodAmount / 2) {
                    for (int x = 0; x < foodAmount; x++) {
                        if (!foodPop[x].isAlive()) {
                            foodPop[x] = new Food();
                        }
                    }
                    foodEaten = 0;
                }
                draw = true;
                
                updateFittest();
            }
        };

        /*
        Both action listeners are called at the same time and do generally the same thing.
        It controls the movement, field of view cone, the collision of the agent and their current state.
        */
        al_predLogic = new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                double rotation, ts, speed, velocityX, velocityY, currentX, currentY;
                Rectangle predRect;
                AffineTransform t;

                if (!pause) {
                    for (int x = 0; x < predAmount; x++) {
                        if (predPop[x].isAlive()) {
                            //bounds setting for collision against prey
                            predRect = predPop[x].getBounds();
                            predRect.setRect(predPop[x].getX(), predPop[x].getY(), predPop[x].getWidth(), predPop[x].getHeight());
                            predPop[x].setBounds(predRect);

                            //border collision detection
                            if (predPop[x].getX() + 5 >= viewPort.getWidth()) {
                                predPop[x].setX(0);
                            } else if (predPop[x].getX() <= 0) {
                                predPop[x].setX(viewPort.getWidth() - 5);
                            }

                            if (predPop[x].getY() <= 0) {
                                predPop[x].setY(viewPort.getHeight() - 5);
                            } else if (predPop[x].getY() + 5 >= viewPort.getHeight()) {
                                predPop[x].setY(0);
                            }

                            t = new AffineTransform();
                            //affinetransform stuff for drawing later
                            t.translate(predPop[x].getX(), predPop[x].getY());
                            //convert the angle to radians so the displayed image is correct to direction of agent
                            t.rotate(Math.toRadians(predPop[x].getRotation()), predPop[x].getWidth() / 2, predPop[x].getHeight() / 2);
                            t.scale(1, 1);
                            predPop[x].setAffineTransform(t);

                            //fov generation notes:
                        /*
                             (x, y, width, start, heigh, extent, pie)
                             http://www.javadocexamples.com/java/awt/geom/java.awt.geom.Arc2D.Double.html
                             X and Y need to be half width with a minor offset to center the fov.
                             */
                            Arc2D fov = new Arc2D.Double(0, 0, predPop[x].getFovLength(), predPop[x].getFovLength(), 0, predPop[x].getFov(), Arc2D.PIE);
                            AffineTransform k = new AffineTransform();
                            k.translate(predPop[x].getX() - predPop[x].getFovLength() / 2 + predPop[x].getWidth() / 2,
                                    predPop[x].getY() - predPop[x].getFovLength() / 2 + predPop[x].getHeight() / 2);
                            double fovd = predPop[x].getFov();
                            double difference = 180 - fovd;
                            difference = difference / 2;
                            k.rotate(Math.toRadians(predPop[x].getRotation() - difference),
                                    predPop[x].getFovLength() / 2, predPop[x].getFovLength() / 2);

                            Shape fovShape = k.createTransformedShape(fov);
                            predPop[x].setFovShape(fovShape);

                            rotation = predPop[x].getRotation();

                            ts = predPop[x].getTurnSpeed();
                            speed = predPop[x].getSpeed();

                            velocityX = Math.sin(rotation * Math.PI / 180) * speed;
                            velocityY = Math.cos(rotation * Math.PI / 180) * -speed;

                            if (rotation >= predPop[x].getAngle()) {
                                rotation -= ts;
                            } else if (rotation <= predPop[x].getAngle()) {
                                rotation += ts;
                            }

                            currentX = predPop[x].getX();
                            currentY = predPop[x].getY();

                            currentX += velocityX;
                            currentY += velocityY;

                            predPop[x].setRotation(rotation);
                            predPop[x].setX(currentX);
                            predPop[x].setY(currentY);

                            switch (predPop[x].getState()) {
                                case Search: {
                                    double distanceX, distanceY, angle;
                                    int prey = predPop[x].getPreyID();

                                    if (!predPop[x].hasTarget()) {
                                        prey = rNumber.nextInt(1 + (preyAmount - 1));
                                        if (preyPop[prey].isAlive()) {
                                            predPop[x].setPreyID(prey);
                                            predPop[x].setTarget(true);

                                        }
                                    }
                                    //update the angle from the predator to the target if its true
                                    if (predPop[x].hasTarget()) {
                                        distanceX = preyPop[prey].getX() - predPop[x].getX();
                                        distanceY = preyPop[prey].getY() - predPop[x].getY();

                                        angle = Math.toDegrees(Math.atan2(distanceY, distanceX));

                                        //When handling trigonometry a 0 is by default facing east. So giving the angle 90 degrees
                                        //would make the prey face South. Adding a flat 90 degrees solves this problem cheaply.
                                        predPop[x].setAngle(angle + 90);

                                    }

                                    /*
                                     Collision between FOV and Food Rectangles.
                                     What it does :
                                     When a food Rectangle is within the boundaries of the FOV cone it will pass the ID of the food to the
                                     prey bot. This is so it can continue following angle to it and eat it
                                     */
                                    for (int j = 0; j < preyAmount; j++) {
                                        if (predPop[x].getFovShape().intersects(preyPop[j].getBounds()) && preyPop[j].isAlive()) {
                                            predPop[x].setPreyID(j);
                                            predPop[x].stateChase();
                                            break;
                                        }
                                    }
                                    break;
                                }

                                case Chase: {

                                    double distanceX, distanceY, angle;
                                    int prey;

                                    prey = predPop[x].getPreyID();

                                    distanceX = preyPop[prey].getX() - predPop[x].getX();
                                    distanceY = preyPop[prey].getY() - predPop[x].getY();

                                    angle = Math.toDegrees(Math.atan2(distanceY, distanceX));

                                    //When handling trigonometry a 0 is by default facing east. So giving the angle 90 degrees
                                    //would make the prey face South. Adding a flat 90 degrees solves this problem cheaply.
                                    predPop[x].setAngle(angle + 90);

                                    if (predPop[x].getBounds().intersects(preyPop[prey].getBounds())) {
                                        if (preyPop[prey].isAlive()) {
                                            predPop[x].addEnergy(predLife);
                                            preyPop[prey].setAlive(false);
                                            predPop[x].setTarget(false);
                                            predPop[x].setPreyID(-1);
                                            predPop[x].stateSearch();
                                            break;
                                        }
                                    }

                                    //If the prey gets out of the field of vision go back to search.
                                    //Effectively the food is forgotten.
                                    if (!predPop[x].getFovShape().contains(preyPop[prey].getBounds())) {
                                        predPop[x].setTarget(false);
                                        predPop[x].stateSearch();
                                    }

                                    break;
                                }
                            }
                            predPop[x].addEnergy(-decay);
                            if (predPop[x].getEnergy() <= 0) {
                                predPop[x].setAlive(false);
                            }
                        }
                    }

                    /*
                     This checks if any bots are alive. If a single one is alive, dont pause the simulation and move
                     to next generation
                     */
                    boolean alive = false;
                    for (int x = 0; x < predPop.length; x++) {
                        if (predPop[x].isAlive()) {
                            alive = true;
                        }
                    }

                    if (!alive) {
                        pause = true;
                        newGen = true;                        
                        stopSim();
                    }
                }
            }
        };

        al_preyLogic = new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {

                double rotation, ts, speed, velocityX, velocityY, currentX, currentY;
                Rectangle preyRect;
                AffineTransform t;

                /*
                 NOTES FOR PREY BEHAVIOUR
                 Search state : Choose a random food location on screen and move there. If vision hits any food
                 switch to Eat state. 
                
                 Eat state : Go to location of food, eat, switch to Search state. If targeted food is eaten by another
                 prey switch to search state.
                
                (not implemented)
                 Escape state : Vision spots predator during search state. Actions are move to a random location opposite
                 the predator ignoring food as you pass. Once at that state spin around 360 if predators then run, if not then switch
                 to search mode.
                 */
                if (!pause) {
                    for (int x = 0; x < preyAmount; x++) {

                        if (preyPop[x].isAlive()) {

                            //border collision detection
                            if (preyPop[x].getX() + 5 >= viewPort.getWidth()) {
                                preyPop[x].setX(0);
                            } else if (preyPop[x].getX() <= 0) {
                                preyPop[x].setX(viewPort.getWidth() - 5);
                            }

                            if (preyPop[x].getY() <= 0) {
                                preyPop[x].setY(viewPort.getHeight() - 5);
                            } else if (preyPop[x].getY() + 5 >= viewPort.getHeight()) {
                                preyPop[x].setY(0);
                            }

                            t = new AffineTransform();
                            //affinetransform stuff for drawing later
                            t.translate(preyPop[x].getX(), preyPop[x].getY());
                            //convert the angle to radians so the displayed image is correct to direction of agent
                            t.rotate(Math.toRadians(preyPop[x].getRotation()), preyPop[x].getWidth() / 2, preyPop[x].getHeight() / 2);
                            t.scale(1, 1);
                            preyPop[x].setAffineTransform(t);

                            //bounds setting for collision against food
                            preyRect = preyPop[x].getBounds();
                            preyRect.setRect(preyPop[x].getX(), preyPop[x].getY(), preyPop[x].getWidth(), preyPop[x].getHeight());
                            preyPop[x].setBounds(preyRect);

                            //fov generation notes:
                        /*
                             x, y, width, height, 0, fov, pie
                             Width and height will be the same value.
                             X and Y need to be half width or height.
                             fov is the actual field of vision number
                             */
                            Arc2D fov = new Arc2D.Double(0, 0, preyPop[x].getFovLength(), preyPop[x].getFovLength(), 0, preyPop[x].getFov(), Arc2D.PIE);
                            AffineTransform k = new AffineTransform();
                            k.translate(preyPop[x].getX() - preyPop[x].getFovLength() / 2 + preyPop[x].getWidth() / 2, preyPop[x].getY() - preyPop[x].getFovLength() / 2 + preyPop[x].getHeight() / 2);
                            double fovd = preyPop[x].getFov();
                            double difference = 180 - fovd;
                            difference = difference / 2;
                            k.rotate(Math.toRadians(preyPop[x].getRotation() - difference), preyPop[x].getFovLength() / 2, preyPop[x].getFovLength() / 2);

                            Shape fovShape = k.createTransformedShape(fov);
                            preyPop[x].setFovShape(fovShape);

                            rotation = preyPop[x].getRotation();

                            ts = preyPop[x].getTurnSpeed();
                            speed = preyPop[x].getSpeed();

                            velocityX = Math.sin(rotation * Math.PI / 180) * speed;
                            velocityY = Math.cos(rotation * Math.PI / 180) * -speed;

                            if (rotation >= preyPop[x].getAngle()) {
                                rotation -= ts;
                            } else if (rotation <= preyPop[x].getAngle()) {
                                rotation += ts;
                            }

                            currentX = preyPop[x].getX();
                            currentY = preyPop[x].getY();

                            currentX += velocityX;
                            currentY += velocityY;

                            preyPop[x].setRotation(rotation);
                            preyPop[x].setX(currentX);
                            preyPop[x].setY(currentY);

                            switch (preyPop[x].getState()) {

                                case Search: {

                                    double distanceX, distanceY, angle;
                                    int food;

                                    for (int j = 0; j < foodAmount; j++) {
                                        if (!preyPop[x].hasTarget() && foodPop[j].isAlive()) {
                                            food = rNumber.nextInt(1 + (foodAmount - 1));

                                            distanceX = foodPop[food].getX() - preyPop[x].getX();
                                            distanceY = foodPop[food].getY() - preyPop[x].getY();

                                            angle = Math.toDegrees(Math.atan2(distanceY, distanceX));

                                            //When handling trigonometry a 0 is by default facing east. So giving the angle 90 degrees
                                            //would make the prey face South. Adding a flat 90 degrees solves this problem cheaply.
                                            preyPop[x].setAngle(angle + 90);

                                            preyPop[x].setTarget(true);
                                            preyPop[x].setFoodID(food);

                                        }
                                    }

                                    /*
                                     Collision between FOV and Food Rectangles.
                                     What it does :
                                     When a food Rectangle is within the boundaries of the FOV cone it will pass the ID of the food to the
                                     prey bot. This is so it can continue following angle to it and eat it
                                     */
                                    for (int j = 0; j < foodAmount; j++) {
                                        if (preyPop[x].getFovShape().contains(foodPop[j].getBounds()) && foodPop[j].isAlive()) {
                                            preyPop[x].setFoodID(j);
                                            preyPop[x].stateEat();
                                            break;
                                        }
                                    }
                                    break;
                                }

                                case Eat: {

                                    for (int j = 0; j < foodAmount; j++) {
                                        double distanceX, distanceY, angle;
                                        int food;

                                        food = preyPop[x].getFoodID();

                                        distanceX = foodPop[food].getX() - preyPop[x].getX();
                                        distanceY = foodPop[food].getY() - preyPop[x].getY();

                                        angle = Math.toDegrees(Math.atan2(distanceY, distanceX));

                                        //When handling trigonometry a 0 is by default facing east. So giving the angle 90 degrees
                                        //would make the prey face South. Adding a flat 90 degrees solves this problem cheaply.
                                        preyPop[x].setAngle(angle + 90);

                                        if (preyPop[x].getBounds().intersects(foodPop[j].getBounds())) {
                                            if (foodPop[j].isAlive()) {
                                                preyPop[x].addEnergy(preyLife);
                                                foodPop[j].setAlive(false);
                                                preyPop[x].setTarget(false);
                                                preyPop[x].setFoodID(-1);
                                                preyPop[x].stateSearch();
                                                break;
                                            }
                                        }

                                        //If at any point there is not a food rectangle in the vision go back to search.
                                        //Effectively the food is forgotten.
                                        if (!preyPop[x].getFovShape().contains(foodPop[j].getBounds())) {
                                            preyPop[x].setTarget(false);
                                            preyPop[x].stateSearch();
                                        }
                                    }
                                    break;
                                }
                            }
                            preyPop[x].addEnergy(-decay);
                            if (preyPop[x].getEnergy() <= 0) {
                                preyPop[x].setEnergy(0);
                                preyPop[x].setAlive(false);
                            }
                        }
                    }

                    /*
                     This checks if any bots are alive. If a single one is alive, dont pause the simulation and move
                     to next generation
                     */
                    boolean alive = false;
                    for (int x = 0; x < preyPop.length; x++) {
                        if (preyPop[x].isAlive()) {
                            alive = true;
                        }
                    }

                    if (!alive) {
                        pause = true;
                        newGen = true;
                        stopSim();
                    }
                    endTime = System.nanoTime();
                    
                    duration = (endTime - startTime) / 1000000000;                    
                    if(duration > 30){
                        pause = true;
                        newGen = true;
                        stopSim();
                    }
                    
                }                
            } 
        };

        temp = jtfFoodPopulation.getText();
        foodAmount = Integer.parseInt(temp);

        temp = jtfPreyPopulation.getText();
        preyAmount = Integer.parseInt(temp);

        temp = jtfPredatorPopulation.getText();
        predAmount = Integer.parseInt(temp);

        temp = jtfMutation.getText();
        mutation = Integer.parseInt(temp);

        temp = jtfMinMutStr.getText();
        minMutStrength = Integer.parseInt(temp);
        
        temp = jtfMaxMutStr.getText();
        maxMutStrength = Integer.parseInt(temp);

        /*
        If the inputs are between the ranges stated and
        minMutStrenght is less than the maxMutStrength then pass, otherwise fail
        */
        if (foodAmount >= 2
                && foodAmount <= 1000
                && preyAmount >= 2
                && preyAmount <= 1000
                && predAmount >= 2
                && predAmount <= 1000
                && mutation >= 0
                && mutation <= 100) 
        {
            if(minMutStrength < maxMutStrength){
                pass = true;
            }
            else
            {
                jtaConsole.append("Min mut str needs to be lower than max mut str!\n");
                pass = false;
            }
            
            //if none of the checkboxes is ticked dont let it pass
            if(!jcbSimNormal.isSelected() && !jcbSimSlow.isSelected() && !jcbSimFast.isSelected()){
                jtaConsole.append("Don't forget to check a speed setting!\n");
                pass = false;
            }
        } else {
            pass = false;
        }

        //basic but lengthy if statement controls the validation of input.
        //Will only continue with the right numbers input
        if (pass) {
            //Food array preperation
            foodPop = new Food[foodAmount];

            for (int x = 0; x < foodAmount; x++) {
                foodPop[x] = new Food();
            }

            //simple border collision, pushes food to be back inside the frame rather than almost out of it
            for (int x = 0; x < foodAmount; x++) {
                //food
                if (foodPop[x].getX() + 9 >= viewPort.getWidth()) {
                    foodPop[x].setX(viewPort.getWidth() - 9);
                } else if (foodPop[x].getX() <= 0) {
                    foodPop[x].setX(0);
                }

                if (foodPop[x].getY() <= 0) {
                    foodPop[x].setY(0);
                } else if (foodPop[x].getY() + 9 >= viewPort.getHeight()) {
                    foodPop[x].setY(viewPort.getHeight() - 9);
                }
            }

            //End of food prep
            //start of prey prep
            preyPop = new Prey[preyAmount];
            for (int x = 0; x < preyAmount; x++) {
                preyPop[x] = new Prey();
            }
            //end of prey prep

            //start of pred prep
            predPop = new Predator[predAmount];
            for (int x = 0; x < predAmount; x++) {
                predPop[x] = new Predator();
            }
            //end of pred prep

            /*NOTES : Currently I can stop and start this timer via the buttons on the
             interface. However it also resets the whole timer. Rendering it a bit useless        
             */
            t_preyTimer = new Timer(timerDelay, al_preyLogic);
            t_preyTimer.setRepeats(true);
            t_preyTimer.start();

            t_predTimer = new Timer(timerDelay, al_predLogic);
            t_predTimer.setRepeats(true);
            t_predTimer.start();

            t_foodTimer = new Timer(timerDelay, al_foodLogic);
            t_foodTimer.setRepeats(true);
            t_foodTimer.start();
            
            ga = new GA();
            
            jtaConsole.append("\nEverything is correct. Running simulation now...\n");
            jbStart.setEnabled(false);
            jcbSimSlow.setEnabled(false);
            jcbSimNormal.setEnabled(false);
            jcbSimNormal.setEnabled(false);
            jcbSimFast.setEnabled(false); 
            startTime = System.nanoTime();
            
            
        } else {
            jtaConsole.append("\nOne or more of your inputs are incorrect!\n");
        }
    }//GEN-LAST:event_jbStartActionPerformed

    private void stopSim() {
        // TODO add your handling code here:
        jbReset.setEnabled(false);
        jtaConsole.append("\nPausing Simulation...\n");

        if (newGen) {
            jtaConsole.append("Creating new generation...\n");
            //Predators
            Predator[] newPredPop;
            newPredPop = new Predator[predAmount];
            newPredPop = ga.processPredatorPopulation(predPop, mutation, minMutStrength, maxMutStrength);
            for (int i = 0; i < newPredPop.length; i++) {
                predPop[i] = newPredPop[i];
            }

            jtaConsole.append("New generation Predators ready...\n");

            //Prey
            Prey[] newPreyPop;
            newPreyPop = new Prey[preyAmount];
            newPreyPop = ga.processPreyPopulation(preyPop, mutation, minMutStrength, maxMutStrength);
            for (int i = 0; i < newPreyPop.length; i++) {
                preyPop[i] = newPreyPop[i];
            }

            jtaConsole.append("New generation Prey ready...\n");

            ga.updateLog(foodAmount);
            ga.dumpLog(foodAmount);
            jtaConsole.append("Log updated...\n");
            //shortcut to resetting food
            newGen = false;

            resumeSim();
        }
    }
    
    private void viewPortMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_viewPortMouseMoved
        // TODO add your handling code here:
        //System.out.println(viewPort.getMousePosition());
    }//GEN-LAST:event_viewPortMouseMoved

    private void resumeSim(){
        jbReset.setEnabled(true);
        pause = false;
        startTime = System.nanoTime();
        jtaConsole.append("\nResuming Simulation...\n");
    }
    
    /*
    updateFittest
    This method will search through all the remaining prey and predators that are alive and find the fittest member
    */
    private void updateFittest(){
        double[] tPreyFitness = new double[preyPop.length];
        for (int i = 0; i < preyPop.length; i++) {
            if(preyPop[i].isAlive()){
                tPreyFitness[i] = preyPop[i].getFitness();
            }
        }
        
        double tempPrey = 0;

        for (int i = 0; i < preyPop.length; i++) {
            if (tPreyFitness[i] > tempPrey) {
                tempPrey = tPreyFitness[i];
                preySelected = i;
            }
        }
        
        double[] tPredFitness = new double[predPop.length];
        for (int i = 0; i < predPop.length; i++) {
            if (predPop[i].isAlive()) {
                tPredFitness[i] = predPop[i].getFitness();
            }
        }

        double tempPred = 0;

        for (int i = 0; i < predPop.length; i++) {
            if (tPredFitness[i] > tempPred) {
                tempPred = tPredFitness[i];
                predSelected = i;
            }
        }
    }
    
    private void viewPortMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_viewPortMouseClicked

    }//GEN-LAST:event_viewPortMouseClicked

    private void jcbSimSlowActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jcbSimSlowActionPerformed
        // TODO add your handling code here:
        jcbSimNormal.setSelected(false);
        jcbSimFast.setSelected(false);
        timerDelay = 300;
    }//GEN-LAST:event_jcbSimSlowActionPerformed

    private void jcbSimNormalActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jcbSimNormalActionPerformed
        // TODO add your handling code here:
        jcbSimSlow.setSelected(false);
        jcbSimFast.setSelected(false);
        timerDelay = 100;
    }//GEN-LAST:event_jcbSimNormalActionPerformed

    private void jcbSimFastActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jcbSimFastActionPerformed
        // TODO add your handling code here:
        jcbSimSlow.setSelected(false);
        jcbSimNormal.setSelected(false);
        timerDelay = 20;
    }//GEN-LAST:event_jcbSimFastActionPerformed

    private void jcbFovActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jcbFovActionPerformed
        // TODO add your handling code here:
        if (jcbFov.isSelected()) {
            showFov = true;
        } else {
            showFov = false;
        }
    }//GEN-LAST:event_jcbFovActionPerformed

    private void jtfMaxMutStrKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jtfMaxMutStrKeyReleased
        // TODO add your handling code here:
        int temp = evt.getKeyCode();
        if(temp == 10){
            jbStart.doClick();
        }
    }//GEN-LAST:event_jtfMaxMutStrKeyReleased

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NBGeneticAlgorithm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NBGeneticAlgorithm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NBGeneticAlgorithm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NBGeneticAlgorithm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new NBGeneticAlgorithm().setVisible(true);
            }
        });

        //Code goes here
    }

    // Variables declaration - do not modify                     
    // End of variables declaration                   
//This class is a custom JPanel class that allows
//overrides so that it is possible to draw to the
//panel
//For simplicity sake everything graphic related i.e, loading images are done here
    class MyPanel extends JPanel {

        public Graphics2D g2d;
        private double width, height;
        private BufferedImage scene;

        //create the 3 populations for grass, prey and predator.
        //Base them off of the input from the user
        public MyPanel(int x, int y, int w, int h) {
            width = w;
            height = h;

            /* setup the memory image, which supports sub-pixel (double) precision */
            scene = new BufferedImage(w, h, 1);
            g2d = scene.createGraphics();
            g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
            g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

            /* setup the ui component */
            this.setLocation(x, y);
            this.setSize(w, h);

            try {
                grassImage = ImageIO.read(this.getClass().getResource("Resources/grass.png"));
                preyImage = ImageIO.read(this.getClass().getResource("Resources/prey.png"));
                predatorImage = ImageIO.read(this.getClass().getResource("Resources/predator.png"));
            } catch (IOException e) {
                System.out.println("Couldn't find images");
            }
        }

        public void updateFields() {

            double energy, speed, turnSpeed, fov, fovWidth, ID;
            int gen;

            if (predSelected >= 0) {
                //predator
                energy = predPop[predSelected].getEnergy();
                speed = predPop[predSelected].getSpeed();
                turnSpeed = predPop[predSelected].getTurnSpeed();
                fov = predPop[predSelected].getFov();
                fovWidth = predPop[predSelected].getFovLength();
                ID = predSelected;

                jtfPred_Energy.setText(new DecimalFormat("##.##").format(energy));
                jtfPred_Speed.setText(new DecimalFormat("##.##").format(speed));
                jtfPred_Turn_speed.setText(new DecimalFormat("##.##").format(turnSpeed));
                jtfPred_Fov.setText(new DecimalFormat("##.##").format(fov));
                jtfPred_Fov_Width.setText(new DecimalFormat("##.##").format(fovWidth));
                jtfPred_ID.setText(new DecimalFormat("##.##").format(ID));
            }

            if (preySelected >= 0) {
                //prey
                energy = preyPop[preySelected].getEnergy();
                speed = preyPop[preySelected].getSpeed();
                turnSpeed = preyPop[preySelected].getTurnSpeed();
                fov = preyPop[preySelected].getFov();
                fovWidth = preyPop[preySelected].getFovLength();
                ID = preySelected;

                jtfPrey_Energy.setText(new DecimalFormat("##.##").format(energy));
                jtfPrey_Speed.setText(new DecimalFormat("##.##").format(speed));
                jtfPrey_Turn_speed.setText(new DecimalFormat("##.##").format(turnSpeed));
                jtfPrey_Fov.setText(new DecimalFormat("##.##").format(fov));
                jtfPrey_Fov_Width.setText(new DecimalFormat("##.##").format(fovWidth));
                jtfPrey_ID.setText(new DecimalFormat("##.##").format(ID));
            }

            gen = ga.getPredGeneration();
            jtfPredGeneration.setText(new DecimalFormat("####").format(gen));

            gen = ga.getPreyGeneration();
            jtfPreyGeneration.setText(new DecimalFormat("####").format(gen));

        }

        @Override
        public void paintComponent(Graphics g) {
            super.paintComponent(g);

            g2d.clearRect(0, 0, (int) width, (int) height);
            Color background = new Color(87, 57, 57);
            g2d.setBackground(background);
            //draw all of the grass as long as they are alive

            //change this so the affine transform is set during grass creation rather than in the drawloop
            if (draw && !newGen) {

                for (int x = 0; x < foodAmount; x++) {
                    if (foodPop[x].isAlive()) {
                        AffineTransform t = new AffineTransform();
                        t.translate(foodPop[x].getX(), foodPop[x].getY());
                        t.scale(1, 1);
                        g2d.drawImage(grassImage, t, this);
                    }
                }

                for (int x = 0; x < preyAmount; x++) {
                    if (preyPop[x].isAlive()) {
                        g2d.drawImage(preyImage, preyPop[x].getAffineTransform(), this);
                    }

                    if (showFov && preyPop[preySelected].isAlive()) {
                        g2d.draw(preyPop[preySelected].getFovShape());
                    }
                }

                for (int x = 0; x < predAmount; x++) {
                    if (predPop[x].isAlive()) {
                        g2d.drawImage(predatorImage, predPop[x].getAffineTransform(), this);
                    }
                    if (showFov && predPop[predSelected].isAlive()) {
                        g2d.draw(predPop[predSelected].getFovShape());
                    }
                }
                updateFields();                
            }

            g.drawImage(scene, 0, 0, this);
            repaint();
        }
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JButton jbReset;
    private javax.swing.JButton jbStart;
    private javax.swing.JCheckBox jcbFov;
    private javax.swing.JCheckBox jcbSimFast;
    private javax.swing.JCheckBox jcbSimNormal;
    private javax.swing.JCheckBox jcbSimSlow;
    private javax.swing.JLabel jlFoodPopulation;
    private javax.swing.JLabel jlFoodPopulationHint;
    private javax.swing.JLabel jlMaxStrHint;
    private javax.swing.JLabel jlMinMutStr;
    private javax.swing.JLabel jlMinMutStrHint;
    private javax.swing.JLabel jlMutation;
    private javax.swing.JLabel jlMutationHint;
    private javax.swing.JLabel jlMutationStrHint;
    private javax.swing.JLabel jlPredGeneration;
    private javax.swing.JLabel jlPredID;
    private javax.swing.JLabel jlPredTurn_speed;
    private javax.swing.JLabel jlPred_Energy;
    private javax.swing.JLabel jlPred_Fov;
    private javax.swing.JLabel jlPred_Fov_Width;
    private javax.swing.JLabel jlPred_Speed;
    private javax.swing.JLabel jlPredatorPopulation;
    private javax.swing.JLabel jlPredatorPopulationHint;
    private javax.swing.JLabel jlPreyGeneration;
    private javax.swing.JLabel jlPreyID;
    private javax.swing.JLabel jlPreyPopulation;
    private javax.swing.JLabel jlPreyPopulationHint;
    private javax.swing.JLabel jlPreyTurn_speed;
    private javax.swing.JLabel jlPrey_Energy;
    private javax.swing.JLabel jlPrey_Fov;
    private javax.swing.JLabel jlPrey_Fov_Width;
    private javax.swing.JLabel jlPrey_Speed;
    private javax.swing.JLabel jlSimSpeed;
    private javax.swing.JTextArea jtaConsole;
    private javax.swing.JTextField jtfFoodPopulation;
    private javax.swing.JTextField jtfMaxMutStr;
    private javax.swing.JTextField jtfMinMutStr;
    private javax.swing.JTextField jtfMutation;
    private javax.swing.JTextField jtfPredGeneration;
    private javax.swing.JTextField jtfPred_Energy;
    private javax.swing.JTextField jtfPred_Fov;
    private javax.swing.JTextField jtfPred_Fov_Width;
    private javax.swing.JTextField jtfPred_ID;
    private javax.swing.JTextField jtfPred_Speed;
    private javax.swing.JTextField jtfPred_Turn_speed;
    private javax.swing.JTextField jtfPredatorPopulation;
    private javax.swing.JTextField jtfPreyGeneration;
    private javax.swing.JTextField jtfPreyPopulation;
    private javax.swing.JTextField jtfPrey_Energy;
    private javax.swing.JTextField jtfPrey_Fov;
    private javax.swing.JTextField jtfPrey_Fov_Width;
    private javax.swing.JTextField jtfPrey_ID;
    private javax.swing.JTextField jtfPrey_Speed;
    private javax.swing.JTextField jtfPrey_Turn_speed;
    private javax.swing.JPanel viewPort;
    // End of variables declaration//GEN-END:variables
}
